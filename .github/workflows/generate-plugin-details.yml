name: Generate Plugin Details

on:
  push:
    branches:
      - main
    paths:
      - 'plugins.json'
  schedule:
    - cron: '0 0 */2 * *'
  workflow_dispatch:

jobs:
  generate-details:
    runs-on: ubuntu-latest
    permissions:
        contents: write
        issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN  }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @actions/core

      - name: Generate plugin details
        id: generate
        run: |
          node <<'EOL'
          const fs = require('fs');
          const https = require('https');
          const core = require('@actions/core');

          async function main() {
            try {
              console.log('🚀 开始生成插件详情...');
              console.log('正在读取 plugins.json 文件...');
              const plugins = JSON.parse(fs.readFileSync('plugins.json', 'utf8'));
              console.log(`✅ 成功读取 plugins.json，发现 ${plugins.length} 个插件`);

              // 读取现有的 plugin_details.json 以保留 createdAt 时间
              let existingDetails = new Map();
              if (fs.existsSync('plugin_details.json')) {
                console.log('发现现有的 plugin_details.json，正在读取...');
                const oldDetails = JSON.parse(fs.readFileSync('plugin_details.json', 'utf8'));
                for (const detail of oldDetails) {
                  existingDetails.set(detail.id, detail.createdAt);
                }
                console.log(`✅ 成功读取 ${existingDetails.size} 个现有插件的创建时间`);
              }

              // 跳过第一个插件
              const pluginsToProcess = plugins.slice(1);
              console.log(`准备处理 ${pluginsToProcess.length} 个插件（跳过第一个）`);

              const pluginDetails = [];
              const errors = [];

              for (const plugin of pluginsToProcess) {
                try {
                  console.log(`\n=== 正在获取插件清单：${plugin.id} ===`);
                  console.log(`仓库地址：${plugin.repositoryUrl}`);
                  const manifest = await fetchManifest(plugin.repositoryUrl);
                  
                  const createdAt = existingDetails.get(plugin.id) || new Date().toISOString();

                  pluginDetails.push({
                    id: plugin.id,
                    manifest: manifest,
                    createdAt: createdAt
                  });
                  
                  console.log(`✅ 成功处理插件：${plugin.id}`);
                } catch (error) {
                  const errorMsg = `插件 ${plugin.id} 处理失败：${error.message}`;
                  console.error(`❌ ${errorMsg}`);
                  errors.push(errorMsg);
                  // 继续处理其他插件，不中断整个流程
                }
              }

              // 写入 plugin_details.json 文件
              fs.writeFileSync('plugin_details.json', JSON.stringify(pluginDetails, null, 2));
              console.log(`\n✅ 生成 plugin_details.json 文件，包含 ${pluginDetails.length} 个插件`);

              // 生成 commit message
              let commitMessage = `自动生成 plugin_details.json`;
              if (pluginDetails.length > 0) {
                const pluginNames = pluginDetails.map(p => p.id).slice(0, 5).join(', ');
                commitMessage += `\n\n更新了 ${pluginDetails.length} 个插件，包括：${pluginNames}`;
                if (pluginDetails.length > 5) {
                  commitMessage += ' 等...';
                }
              }
              // 将 commit message 写入 GITHUB_OUTPUT
              const commitMessageKey = 'commit_message';
              const eofMarker = `EOF_${Math.random().toString(36).substring(2, 15)}`;
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${commitMessageKey}<<${eofMarker}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${commitMessage}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${eofMarker}\n`);


              // 报告错误统计
              if (errors.length > 0) {
                console.warn(`\n⚠️  处理过程中发现 ${errors.length} 个错误：`);
                errors.forEach((error, index) => {
                  console.warn(`${index + 1}. ${error}`);
                });
                console.warn(`\n成功率：${pluginDetails.length}/${pluginsToProcess.length} (${Math.round(pluginDetails.length / pluginsToProcess.length * 100)}%)`);
              } else {
                console.log(`\n🎉 所有插件处理成功！`);
              }

            } catch (error) {
              console.error(`❌ 处理失败：${error.message}`);
              process.exit(1);
            }
          }

          async function fetchManifest(repoUrl) {
            console.log(`\n🔍 开始为 ${repoUrl} 获取清单...`);
            const branches = ['main', 'master'];
            const filePaths = ['__init__.py', 'src/__init__.py', 'app/__init__.py']; // 常见路径

            for (const branch of branches) {
              for (const path of filePaths) {
                const rawUrl = repoUrl.replace('github.com', 'raw.githubusercontent.com') + `/${branch}/${path}`;
                console.log(`尝试从 ${branch} 分支的 ${path} 获取元数据：${rawUrl}`);
                
                try {
                  const fileContent = await fetchFileContent(rawUrl);
                  const metadata = parseMetadata(fileContent);
                  if (metadata) {
                    console.log(`✅ 成功从 ${branch} 分支的 ${path} 获取到元数据`);
                    return metadata;
                  }
                } catch (error) {
                  console.log(`❌ 在 ${branch} 分支的 ${path} 获取失败: ${error.message}`);
                }
              }
            }

            console.error(`❌ 在所有预设路径和分支中都未能找到 ${repoUrl} 的有效元数据。`);
            throw new Error(`无法从任何分支或路径获取有效的 __plugin_meta__。请检查仓库结构和文件内容。仓库地址：${repoUrl}`);
          }

          function fetchFileContent(url) {
            return new Promise((resolve, reject) => {
              console.log(`[GET] -> 正在请求 URL: ${url}`);
              const req = https.get(url, res => {
                if (res.statusCode !== 200) {
                  console.error(`[${res.statusCode}] <- 请求 ${url} 失败。`);
                  return reject(new Error(`状态码：${res.statusCode}`));
                }
                console.log(`[200 OK] <- 收到来自 ${url} 的成功响应。`);
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', err => {
                  console.error(`读取响应数据时出错: ${err.message}`);
                  reject(new Error(`读取响应数据时出错：${err.message}`));
                });
              });
              req.on('error', err => {
                console.error(`网络错误: ${err.message}`);
                reject(new Error(`网络错误：${err.message}`));
              });
              req.setTimeout(10000, () => {
                console.error(`请求超时: ${url}`);
                req.destroy();
                reject(new Error(`请求超时`));
              });
            });
          }
          
          function parseMetadata(content) {
            console.log('  [调试] 开始解析 __plugin_meta__ 内容...');
            const match = content.match(/__plugin_meta__\s*=\s*PluginMetadata\s*\(([\s\S]*?)\)/);
            if (!match || !match[1]) {
              console.log('  [调试] 未找到 __plugin_meta__ 匹配项。');
              return null;
            }

            console.log('  [调试] 成功匹配到 __plugin_meta__，准备将其转换为 JSON...');
            // 移除末尾可能存在的逗号和空白
            let paramsStr = match[1].trim().replace(/,$/, '').trim();

            // 1. 移除注释
            paramsStr = paramsStr.replace(/#.*$/gm, '');

            // 2. 替换 Python 的布尔值和 None
            paramsStr = paramsStr.replace(/\bTrue\b/g, 'true')
                                 .replace(/\bFalse\b/g, 'false')
                                 .replace(/\bNone\b/g, 'null');

            // 3. 将三引号字符串统一为单行，并转义
            paramsStr = paramsStr.replace(/"""([\s\S]*?)"""/g, (match, p1) => `"${p1.replace(/\n/g, '\\n').replace(/"/g, '\\"')}"`);
            paramsStr = paramsStr.replace(/'''([\s\S]*?)'''/g, (match, p1) => `"${p1.replace(/\n/g, '\\n').replace(/"/g, '\\"')}"`);

            // 4. 将所有单引号统一为双引号（除了已经被转义的）
            paramsStr = paramsStr.replace(/'/g, '"');

            // 5. 为参数名添加双引号 (key=value -> "key":value)
            // 正则表达式解释:
            // (\w+)\s*=\s*  匹配一个或多个单词字符（键），后面跟着可选的空格，一个等号，和可选的空格
            // (?=...)       是一个正向先行断言，确保后面的内容是...
            // (?:           非捕获组的开始
            //   "           匹配一个双引号
            //   |           或者
            //   \[          匹配一个左方括号（数组开始）
            //   |           或者
            //   \{          匹配一个左大括号（对象开始）
            //   |           或者
            //   \d+         匹配一个或多个数字
            //   |           或者
            //   true|false|null 匹配布尔值或null
            // )             非捕获组的结束
            paramsStr = paramsStr.replace(/(\w+)\s*=\s*(?=(?:"|\[|\{|\d+|true|false|null))/g, '"$1": ');
            
            // 6. 将整个字符串包裹成一个 JSON 对象
            const jsonStr = `{${paramsStr}}`;

            try {
              const metadata = JSON.parse(jsonStr);
              console.log(`  [调试] 解析完成，最终对象: ${JSON.stringify(metadata, null, 2)}`);
              return metadata;
            } catch (error) {
              console.error('  [调试] JSON 解析失败:', error);
              console.error('  [调试] 转换后的字符串:', pyDictStr);
              return null;
            }
          }

          main();
          EOL

      - name: Commit and push plugin details
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add plugin_details.json
          if git diff --staged --quiet; then
            echo "没有变更需要提交"
          else
            git commit -m "${{ steps.generate.outputs.commit_message }}"
            git push https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main
            echo "✅ 已提交并推送 plugin_details.json 更新"
          fi
