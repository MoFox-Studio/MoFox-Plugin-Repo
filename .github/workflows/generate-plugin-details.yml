name: Generate Plugin Details

on:
  push:
    branches:
      - main
    paths:
      - 'plugins.json'
  schedule:
    - cron: '0 0 */2 * *'
  workflow_dispatch:

jobs:
  generate-details:
    runs-on: ubuntu-latest
    permissions:
        contents: write
        issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN  }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @actions/core

      - name: Generate plugin details
        id: generate
        run: |
          node <<'EOL'
          const fs = require('fs');
          const https = require('https');
          const core = require('@actions/core');

          async function main() {
            try {
              console.log('🚀 开始生成插件详情...');
              console.log('正在读取 plugins.json 文件...');
              const plugins = JSON.parse(fs.readFileSync('plugins.json', 'utf8'));
              console.log(`✅ 成功读取 plugins.json，发现 ${plugins.length} 个插件`);

              // 读取现有的 plugin_details.json 以保留 createdAt 时间
              let existingDetails = new Map();
              if (fs.existsSync('plugin_details.json')) {
                console.log('发现现有的 plugin_details.json，正在读取...');
                const oldDetails = JSON.parse(fs.readFileSync('plugin_details.json', 'utf8'));
                for (const detail of oldDetails) {
                  existingDetails.set(detail.id, detail.createdAt);
                }
                console.log(`✅ 成功读取 ${existingDetails.size} 个现有插件的创建时间`);
              }

              // 跳过第一个插件
              const pluginsToProcess = plugins.slice(1);
              console.log(`准备处理 ${pluginsToProcess.length} 个插件（跳过第一个）`);

              const pluginDetails = [];
              const errors = [];

              for (const plugin of pluginsToProcess) {
                try {
                  console.log(`\n=== 正在获取插件清单：${plugin.id} ===`);
                  console.log(`仓库地址：${plugin.repositoryUrl}`);
                  const manifest = await fetchManifest(plugin.repositoryUrl);
                  
                  const createdAt = existingDetails.get(plugin.id) || new Date().toISOString();

                  pluginDetails.push({
                    id: plugin.id,
                    manifest: manifest,
                    createdAt: createdAt
                  });
                  
                  console.log(`✅ 成功处理插件：${plugin.id}`);
                } catch (error) {
                  const errorMsg = `插件 ${plugin.id} 处理失败：${error.message}`;
                  console.error(`❌ ${errorMsg}`);
                  errors.push(errorMsg);
                  // 继续处理其他插件，不中断整个流程
                }
              }

              // 写入 plugin_details.json 文件
              fs.writeFileSync('plugin_details.json', JSON.stringify(pluginDetails, null, 2));
              console.log(`\n✅ 生成 plugin_details.json 文件，包含 ${pluginDetails.length} 个插件`);

              // 生成 commit message
              let commitMessage = `自动生成 plugin_details.json`;
              if (pluginDetails.length > 0) {
                const pluginNames = pluginDetails.map(p => p.id).slice(0, 5).join(', ');
                commitMessage += `\n\n更新了 ${pluginDetails.length} 个插件，包括：${pluginNames}`;
                if (pluginDetails.length > 5) {
                  commitMessage += ' 等...';
                }
              }
              // 将 commit message 写入 GITHUB_OUTPUT
              const commitMessageKey = 'commit_message';
              const eofMarker = `EOF_${Math.random().toString(36).substring(2, 15)}`;
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${commitMessageKey}<<${eofMarker}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${commitMessage}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${eofMarker}\n`);


              // 报告错误统计
              if (errors.length > 0) {
                console.warn(`\n⚠️  处理过程中发现 ${errors.length} 个错误：`);
                errors.forEach((error, index) => {
                  console.warn(`${index + 1}. ${error}`);
                });
                console.warn(`\n成功率：${pluginDetails.length}/${pluginsToProcess.length} (${Math.round(pluginDetails.length / pluginsToProcess.length * 100)}%)`);
              } else {
                console.log(`\n🎉 所有插件处理成功！`);
              }

            } catch (error) {
              console.error(`❌ 处理失败：${error.message}`);
              process.exit(1);
            }
          }

          async function fetchManifest(repoUrl) {
            console.log(`\n🔍 开始为 ${repoUrl} 获取清单...`);
            const branches = ['main', 'master'];
            const filePaths = ['__init__.py', 'src/__init__.py', 'app/__init__.py']; // 常见路径

            for (const branch of branches) {
              for (const path of filePaths) {
                const rawUrl = repoUrl.replace('github.com', 'raw.githubusercontent.com') + `/${branch}/${path}`;
                console.log(`尝试从 ${branch} 分支的 ${path} 获取元数据：${rawUrl}`);
                
                try {
                  const fileContent = await fetchFileContent(rawUrl);
                  const metadata = parseMetadata(fileContent);
                  if (metadata) {
                    console.log(`✅ 成功从 ${branch} 分支的 ${path} 获取到元数据`);
                    return metadata;
                  }
                } catch (error) {
                  console.log(`❌ 在 ${branch} 分支的 ${path} 获取失败: ${error.message}`);
                }
              }
            }

            console.error(`❌ 在所有预设路径和分支中都未能找到 ${repoUrl} 的有效元数据。`);
            throw new Error(`无法从任何分支或路径获取有效的 __plugin_meta__。请检查仓库结构和文件内容。仓库地址：${repoUrl}`);
          }

          function fetchFileContent(url) {
            return new Promise((resolve, reject) => {
              console.log(`[GET] -> 正在请求 URL: ${url}`);
              const req = https.get(url, res => {
                if (res.statusCode !== 200) {
                  console.error(`[${res.statusCode}] <- 请求 ${url} 失败。`);
                  return reject(new Error(`状态码：${res.statusCode}`));
                }
                console.log(`[200 OK] <- 收到来自 ${url} 的成功响应。`);
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', err => {
                  console.error(`读取响应数据时出错: ${err.message}`);
                  reject(new Error(`读取响应数据时出错：${err.message}`));
                });
              });
              req.on('error', err => {
                console.error(`网络错误: ${err.message}`);
                reject(new Error(`网络错误：${err.message}`));
              });
              req.setTimeout(10000, () => {
                console.error(`请求超时: ${url}`);
                req.destroy();
                reject(new Error(`请求超时`));
              });
            });
          }
          
          function parseMetadata(content) {
            console.log('  [解析器] 启动元数据解析流程...');
            // 阶段 1: 粗略匹配 __plugin_meta__ 块
            const match = content.match(/__plugin_meta__\s*=\s*PluginMetadata\s*\(([\s\S]*?)\)/);
            if (!match || !match[1]) {
              console.warn('  [解析器] 阶段 1 失败: 未找到 `__plugin_meta__ = PluginMetadata(...)` 结构。');
              return null;
            }
            console.log('  [解析器] 阶段 1 成功: 已定位到 `PluginMetadata` 的参数内容。');
            
            const metadataStr = match[1].trim();
            const json = {};
            
            // 阶段 2: 逐行解析，智能处理多行字符串
            console.log('  [解析器] 阶段 2 开始: 逐行解析键值对...');
            const lines = metadataStr.split('\n').filter(line => line.trim().length > 0);
            let currentKey = null;
            let currentValue = '';
            let inMultilineString = false;
            let multilineQuote = '';

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                console.log(`    [行 ${i+1}] 正在处理: \`${trimmedLine}\``);

                // 如果在多行字符串内部
                if (inMultilineString) {
                    currentValue += '\n' + line; // 保留原始换行和缩进
                    if (trimmedLine.endsWith(multilineQuote)) {
                        console.log(`      [多行] 检测到结束符 \`${multilineQuote}\`，多行字符串 \`${currentKey}\` 录入完毕。`);
                        inMultilineString = false;
                        // 移除首尾的三个引号并去除内部不必要的空白
                        const finalValue = currentValue.substring(multilineQuote.length, currentValue.lastIndexOf(multilineQuote)).trim();
                        json[currentKey] = finalValue;
                        console.log(`      [赋值] ${currentKey} = "${finalValue}"`);
                        currentKey = null;
                        currentValue = '';
                    }
                    continue;
                }

                // 尝试匹配 "key = value" 结构
                const assignmentMatch = trimmedLine.match(/^(\w+)\s*=\s*(.*)/);
                if (assignmentMatch) {
                    const [, key, value] = assignmentMatch;
                    const cleanedValue = value.replace(/,$/, '').trim(); // 移除末尾可能存在的逗号
                    console.log(`      [匹配] 发现键值对: \`${key}\` = \`${cleanedValue}\``);

                    // 检查是否是多行字符串的开始
                    if (cleanedValue.startsWith('"""') || cleanedValue.startsWith("'''")) {
                        console.log(`      [多行] 检测到开始符 \`${cleanedValue.slice(0, 3)}\`，启动多行模式。`);
                        inMultilineString = true;
                        multilineQuote = cleanedValue.slice(0, 3);
                        currentKey = key;
                        currentValue = cleanedValue; // 从包含引号开始，方便后续拼接
                        
                        // 处理单行就结束了的多行字符串，例如 description = """hello"""
                        if (cleanedValue.endsWith(multilineQuote) && cleanedValue.length > 5) {
                            console.log(`      [多行] (特殊情况) 多行字符串在单行内闭合。`);
                            inMultilineString = false;
                            const finalValue = cleanedValue.slice(3, -3).trim();
                            json[key] = finalValue;
                            console.log(`      [赋值] ${key} = "${finalValue}"`);
                            currentKey = null;
                            currentValue = '';
                        }
                    } else {
                        // 普通的单行字符串
                        const finalValue = cleanedValue.replace(/^['"]|['"]$/g, '');
                        json[key] = finalValue;
                        console.log(`      [赋值] ${key} = "${finalValue}"`);
                    }
                } else {
                    console.log(`    [行 ${i+1}] 跳过: 未匹配到 "key = value" 结构。`);
                }
            }
            console.log('  [解析器] 阶段 2 结束: 所有行处理完毕。');

            // 阶段 3: 返回结果
            if (Object.keys(json).length > 0) {
              console.log(`  [解析器] 阶段 3 成功: 解析完成，共获得 ${Object.keys(json).length} 个键值对。`);
              console.log(`  [解析器] 最终结果: ${JSON.stringify(json, null, 2)}`);
              return json;
            } else {
              console.error('  [解析器] 阶段 3 失败: 未能从 `__plugin_meta__` 中解析出任何有效数据。请检查格式。');
              return null;
            }
          }

          main();
          EOL

      - name: Commit and push plugin details
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add plugin_details.json
          if git diff --staged --quiet; then
            echo "没有变更需要提交"
          else
            git commit -m "${{ steps.generate.outputs.commit_message }}"
            git push https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git HEAD:main
            echo "✅ 已提交并推送 plugin_details.json 更新"
          fi
