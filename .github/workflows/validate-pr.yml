# GitHub Action åç§°
name: Validate Plugin Submission

# è§¦å‘å·¥ä½œæµç¨‹çš„äº‹ä»¶
on:
  # ä½¿ç”¨ pull_request_target ä»¥è·å¾—å†™å…¥è¯„è®ºçš„æƒé™
  # æ³¨æ„ï¼šæ­¤äº‹ä»¶åœ¨ä¸»ä»“åº“ä¸Šä¸‹æ–‡ä¸­è¿è¡Œï¼Œå…·æœ‰å†™å…¥æƒé™
  pull_request_target:
    # ä»…é’ˆå¯¹ç›®æ ‡æ˜¯ main åˆ†æ”¯çš„ pull request
    branches:
      - main
    # ä»…å½“ plugins.json æ–‡ä»¶è¢«ä¿®æ”¹æ—¶è§¦å‘
    paths:
      - 'plugins.json'

# å®šä¹‰ä¸€ä¸ªæˆ–å¤šä¸ªä½œä¸š
jobs:
  # ä½œä¸šçš„å”¯ä¸€æ ‡è¯†ç¬¦
  validate:
    # æŒ‡å®šä½œä¸šè¿è¡Œçš„è™šæ‹Ÿç¯å¢ƒ
    runs-on: ubuntu-latest
    # é…ç½® GitHub Token æƒé™
    permissions:
      contents: read
      pull-requests: write
      issues: write
    # ä½œä¸šä¸­æ‰§è¡Œçš„æ­¥éª¤
    steps:
      # æ­¥éª¤ 1: æ£€å‡º main åˆ†æ”¯çš„ä»£ç 
      - name: Checkout main branch
        # ä½¿ç”¨å®˜æ–¹çš„ actions/checkout@v4
        uses: actions/checkout@v4
        with:
          # æŒ‡å®šæ£€å‡ºçš„åˆ†æ”¯ä¸º main
          ref: main
          # å°†ä»£ç æ£€å‡ºåˆ° 'main' ç›®å½•ä¸‹
          path: main

      # æ­¥éª¤ 2: æ£€å‡º pull request åˆ†æ”¯çš„ä»£ç 
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          # æ£€å‡º PR çš„ head refï¼ˆæ¥è‡ª fork çš„åˆ†æ”¯ï¼‰
          ref: ${{ github.event.pull_request.head.sha }}
          # å°†ä»£ç æ£€å‡ºåˆ° 'pr' ç›®å½•ä¸‹
          path: pr

      # æ­¥éª¤ 3: è®¾ç½® Node.js ç¯å¢ƒ
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          # æŒ‡å®š Node.js ç‰ˆæœ¬ä¸º '20'
          node-version: '20'

      # æ­¥éª¤ 4: è®¾ç½® Python ç¯å¢ƒ
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      # æ­¥éª¤ 5: å®‰è£…ä¾èµ–å·¥å…·
      - name: Install dependencies
        run: |
          pip install mofox-plugin-dev-toolkit
          sudo apt-get update && sudo apt-get install -y jq

      # æ­¥éª¤ 6: éªŒè¯æ–°çš„æ’ä»¶æ¡ç›®
      - name: Validate new plugin entry
        id: validate
        continue-on-error: true
        # è¿è¡Œä¸€ä¸ªå†…è”çš„ Node.js è„šæœ¬
        run: |
          node <<'EOL'
          const fs = require('fs');
          const https = require('https');

          // ä¸»å‡½æ•°ï¼Œæ‰§è¡Œæ‰€æœ‰éªŒè¯é€»è¾‘
          async function main() {
            try {
              // è¯»å– main åˆ†æ”¯å’Œ PR åˆ†æ”¯çš„ plugins.json æ–‡ä»¶
              const mainPlugins = JSON.parse(fs.readFileSync('main/plugins.json', 'utf8'));
              const prPlugins = JSON.parse(fs.readFileSync('pr/plugins.json', 'utf8'));

              console.log(`ä¸»åˆ†æ”¯æœ‰ ${mainPlugins.length} ä¸ªæ’ä»¶`);
              console.log(`PR åˆ†æ”¯æœ‰ ${prPlugins.length} ä¸ªæ’ä»¶`);

              // åˆ›å»º Set ä»¥ä¾¿é«˜æ•ˆåœ°æŸ¥æ‰¾ä»“åº“ URL å’Œæ’ä»¶ ID
              const mainRepoUrls = new Set(mainPlugins.map(p => p.repositoryUrl));
              const mainPluginIds = new Set(mainPlugins.map(p => p.id));
              
              // ç­›é€‰å‡ºåœ¨ PR ä¸­æ–°å¢çš„æ’ä»¶
              const newPlugins = prPlugins.filter(p =>
                !mainRepoUrls.has(p.repositoryUrl) && !mainPluginIds.has(p.id)
              );

              // ç­›é€‰å‡ºåœ¨ PR ä¸­è¢«ä¿®æ”¹çš„æ’ä»¶
              const modifiedPlugins = prPlugins.filter(p => {
                const mainPlugin = mainPlugins.find(mp =>
                  mp.repositoryUrl === p.repositoryUrl || mp.id === p.id
                );
                // é€šè¿‡æ¯”è¾ƒ JSON å­—ç¬¦ä¸²æ¥åˆ¤æ–­å†…å®¹æ˜¯å¦å‘ç”Ÿå˜åŒ–
                return mainPlugin && JSON.stringify(mainPlugin) !== JSON.stringify(p);
              });

              // æ£€æŸ¥ PR æ˜¯å¦ç¼ºå°‘ main åˆ†æ”¯ä¸­å·²æœ‰çš„æ’ä»¶ï¼ˆå¯èƒ½æ˜¯åˆå¹¶å†²çªçš„è¿¹è±¡ï¼‰
              const missingPlugins = mainPlugins.filter(mp =>
                !prPlugins.some(p => p.repositoryUrl === mp.repositoryUrl || p.id === mp.id)
              );

              if (missingPlugins.length > 0) {
                console.warn(`âš ï¸  è­¦å‘Šï¼šPR åˆ†æ”¯ç¼ºå°‘ä¸»åˆ†æ”¯ä¸­å­˜åœ¨çš„ ${missingPlugins.length} ä¸ªæ’ä»¶ï¼š`);
                missingPlugins.forEach(p => console.warn(`  - ${p.id} (${p.repositoryUrl})`));
                console.warn(`è¿™è¡¨æ˜ PR åˆ†æ”¯å¯èƒ½å·²è¿‡æ—¶ã€‚å»ºè®®å¯¹ä¸»åˆ†æ”¯è¿›è¡Œå˜åŸºæ“ä½œã€‚`);
              }

              // å¦‚æœæ²¡æœ‰æ–°å¢æˆ–ä¿®æ”¹çš„æ’ä»¶ï¼Œåˆ™æå‰é€€å‡º
              if (newPlugins.length === 0 && modifiedPlugins.length === 0) {
                console.log('åœ¨ plugins.json ä¸­æœªæ£€æµ‹åˆ°æ–°æ’ä»¶æˆ–ä¿®æ”¹çš„æ’ä»¶ã€‚');
                process.exit(0);
              }

              // æ£€æŸ¥ PR å†…éƒ¨æ˜¯å¦å­˜åœ¨é‡å¤çš„ä»“åº“ URL æˆ–æ’ä»¶ ID
              const prRepoUrls = prPlugins.map(p => p.repositoryUrl);
              const prPluginIds = prPlugins.map(p => p.id);
              const duplicateUrls = prRepoUrls.filter((url, index) => prRepoUrls.indexOf(url) !== index);
              const duplicateIds = prPluginIds.filter((id, index) => prPluginIds.indexOf(id) !== index);

              if (duplicateUrls.length > 0) {
                throw new Error(`åœ¨ PR ä¸­å‘ç°é‡å¤çš„ä»“åº“ URLï¼š${duplicateUrls.join(', ')}`);
              }
              if (duplicateIds.length > 0) {
                throw new Error(`åœ¨ PR ä¸­å‘ç°é‡å¤çš„æ’ä»¶ IDï¼š${duplicateIds.join(', ')}`);
              }

              // éªŒè¯æ¯ä¸ª PR åªæäº¤ä¸€ä¸ªæ–°æ’ä»¶
              if (newPlugins.length > 1) {
                throw new Error('é”™è¯¯ï¼šæ¯ä¸ª Pull Request åªèƒ½æäº¤ä¸€ä¸ªæ–°æ’ä»¶ã€‚');
              }

              let validationErrors = [];
              
              // ä¿å­˜éªŒè¯ç»“æœåˆ°æ–‡ä»¶ï¼Œä¾›åç»­æ­¥éª¤ä½¿ç”¨
              const validationResult = {
                newPlugins: [],
                modifiedPlugins: [],
                errors: []
              };

              // éªŒè¯æ‰€æœ‰æ–°å¢çš„æ’ä»¶
              for (const plugin of newPlugins) {
                try {
                  console.log(`\n=== éªŒè¯æ–°æ’ä»¶ï¼š${plugin.id} ===`);
                  console.log(`ä»“åº“åœ°å€ï¼š${plugin.repositoryUrl}`);
                  const metadata = await fetchMetadata(plugin.repositoryUrl);
                  validateMetadata(metadata, plugin);
                  console.log(`âœ… æ–°æ’ä»¶éªŒè¯æˆåŠŸï¼š${plugin.id}\n`);
                  validationResult.newPlugins.push(plugin);
                } catch (error) {
                  const errorMsg = `æ–°æ’ä»¶ ${plugin.id} éªŒè¯å¤±è´¥ï¼š${error.message}`;
                  console.error(`âŒ ${errorMsg}\n`);
                  validationErrors.push(errorMsg);
                  validationResult.errors.push(errorMsg);
                }
              }

              // éªŒè¯æ‰€æœ‰ä¿®æ”¹çš„æ’ä»¶
              for (const plugin of modifiedPlugins) {
                try {
                  console.log(`\n=== éªŒè¯ä¿®æ”¹çš„æ’ä»¶ï¼š${plugin.id} ===`);
                  console.log(`ä»“åº“åœ°å€ï¼š${plugin.repositoryUrl}`);
                  const metadata = await fetchMetadata(plugin.repositoryUrl);
                  validateMetadata(metadata, plugin);
                  console.log(`âœ… ä¿®æ”¹æ’ä»¶éªŒè¯æˆåŠŸï¼š${plugin.id}\n`);
                  validationResult.modifiedPlugins.push(plugin);
                } catch (error) {
                  const errorMsg = `ä¿®æ”¹æ’ä»¶ ${plugin.id} éªŒè¯å¤±è´¥ï¼š${error.message}`;
                  console.error(`âŒ ${errorMsg}\n`);
                  validationErrors.push(errorMsg);
                  validationResult.errors.push(errorMsg);
                }
              }

              // å§‹ç»ˆä¿å­˜éªŒè¯ç»“æœåˆ°æ–‡ä»¶ï¼ˆå³ä½¿æœ‰é”™è¯¯ï¼‰
              fs.writeFileSync('validation-result.json', JSON.stringify(validationResult, null, 2));
              console.log('éªŒè¯ç»“æœå·²ä¿å­˜åˆ° validation-result.json');

              // å¦‚æœå­˜åœ¨ä»»ä½•éªŒè¯é”™è¯¯ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸å¹¶ä½¿ Action å¤±è´¥
              if (validationErrors.length > 0) {
                console.error(`\nâŒ å‘ç° ${validationErrors.length} ä¸ªéªŒè¯é”™è¯¯ï¼š`);
                validationErrors.forEach((error, index) => {
                  console.error(`${index + 1}. ${error}`);
                });
                throw new Error(`æ’ä»¶éªŒè¯å¤±è´¥ï¼Œå…± ${validationErrors.length} ä¸ªé”™è¯¯ã€‚è¯·ä¿®å¤ä¸Šè¿°é—®é¢˜åé‡æ–°æäº¤ã€‚`);
              }

              console.log(`âœ… éªŒè¯æˆåŠŸï¼å¤„ç†äº† ${newPlugins.length} ä¸ªæ–°æ’ä»¶å’Œ ${modifiedPlugins.length} ä¸ªä¿®æ”¹çš„æ’ä»¶ã€‚`);
            } catch (error) {
              console.error(`âŒ éªŒè¯å¤±è´¥ï¼š${error.message}`);
              process.exit(1);
            }
          }

          // ä»æ’ä»¶ä»“åº“è·å–å…ƒæ•°æ®
          async function fetchMetadata(repoUrl) {
            const branches = ['main', 'master'];
            const filePaths = ['__init__.py', 'src/__init__.py', 'app/__init__.py']; // å¸¸è§çš„ __init__.py è·¯å¾„

            for (const branch of branches) {
              for (const path of filePaths) {
                const rawUrl = repoUrl.replace('github.com', 'raw.githubusercontent.com') + `/${branch}/${path}`;
                console.log(`å°è¯•ä» ${branch} åˆ†æ”¯çš„ ${path} è·å–å…ƒæ•°æ®ï¼š${rawUrl}`);
                
                try {
                  const fileContent = await fetchFileContent(rawUrl);
                  const metadata = parseMetadata(fileContent);
                  if (metadata) {
                    console.log(`âœ… æˆåŠŸä» ${branch} åˆ†æ”¯çš„ ${path} è·å–åˆ°å…ƒæ•°æ®`);
                    return metadata;
                  }
                } catch (error) {
                  // æ•è·ç‰¹å®šè·¯å¾„çš„æŠ“å–å¤±è´¥ï¼Œå¹¶ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
                  console.log(`âŒ åœ¨ ${branch} åˆ†æ”¯çš„ ${path} è·å–å¤±è´¥: ${error.message}`);
                }
              }
            }
            // å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œåˆ™æŠ›å‡ºæ€»çš„é”™è¯¯
            throw new Error(`æ— æ³•ä»ä»»ä½•åˆ†æ”¯æˆ–è·¯å¾„è·å–æœ‰æ•ˆçš„ __plugin_meta__ã€‚è¯·æ£€æŸ¥ä»“åº“ç»“æ„å’Œæ–‡ä»¶å†…å®¹ã€‚ä»“åº“åœ°å€ï¼š${repoUrl}`);
          }

          // æŠ“å–æŒ‡å®š URL çš„æ–‡ä»¶å†…å®¹
          function fetchFileContent(url) {
            return new Promise((resolve, reject) => {
              const req = https.get(url, res => {
                if (res.statusCode !== 200) {
                  return reject(new Error(`çŠ¶æ€ç ï¼š${res.statusCode}`));
                }
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', err => reject(new Error(`è¯»å–å“åº”æ•°æ®æ—¶å‡ºé”™ï¼š${err.message}`)));
              });
              req.on('error', err => reject(new Error(`ç½‘ç»œé”™è¯¯ï¼š${err.message}`)));
              req.setTimeout(10000, () => { // 10ç§’è¶…æ—¶
                req.destroy();
                reject(new Error(`è¯·æ±‚è¶…æ—¶`));
              });
            });
          }
          
          // ä» __init__.py æ–‡ä»¶å†…å®¹ä¸­è§£æ __plugin_meta__
          function parseMetadata(content) {
            const match = content.match(/__plugin_meta__\s*=\s*PluginMetadata\s*\(([\s\S]*?)\)/);
            if (!match || !match[1]) {
              return null;
            }
            
            let metadataStr = match[1];
            const json = {};
            
            // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…é”®å€¼å¯¹
            const regex = /(\w+)\s*=\s*("(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\[.*?\]|\{.*?\}|[\w\.]+)/g;
            let item;
            while ((item = regex.exec(metadataStr)) !== null) {
               const key = item[1];
               let value = item[2];
               try {
                   // å°è¯•å°† Python å­—é¢é‡è½¬æ¢ä¸º JSON å…¼å®¹æ ¼å¼å¹¶è§£æ
                   value = value.replace(/\bTrue\b/g, 'true')
                                .replace(/\bFalse\b/g, 'false')
                                .replace(/\bNone\b/g, 'null')
                                .replace(/'/g, '"');
                   json[key] = JSON.parse(value);
               } catch (e) {
                   // å¦‚æœè§£æå¤±è´¥ï¼Œåˆ™ä½œä¸ºæ™®é€šå­—ç¬¦ä¸²å¤„ç†
                   json[key] = value.replace(/^['"]|['"]$/g, '');
               }
            }
            
            return Object.keys(json).length > 0 ? json : null;
          }

          // éªŒè¯å…ƒæ•°æ®çš„ç»“æ„å’Œå†…å®¹
          function validateMetadata(metadata, plugin) {
            if (!metadata || typeof metadata !== 'object') {
              throw new Error('__init__.py æ–‡ä»¶ä¸­ç¼ºå°‘æœ‰æ•ˆçš„ __plugin_meta__');
            }

            const requiredFields = ['name', 'version', 'description', 'author'];
            for (const field of requiredFields) {
              if (!metadata[field]) throw new Error(`__plugin_meta__ ç¼ºå°‘å¿…éœ€å­—æ®µï¼š'${field}'`);
            }
            
            // éªŒè¯ç‰ˆæœ¬å·æ ¼å¼æ˜¯å¦ç¬¦åˆè¯­ä¹‰åŒ–ç‰ˆæœ¬
            const versionRegex = /^\d+\.\d+\.\d+/;
            if (!versionRegex.test(metadata.version)) {
              console.warn(`è­¦å‘Šï¼šæ’ä»¶ç‰ˆæœ¬ '${metadata.version}' ä¸ç¬¦åˆè¯­ä¹‰åŒ–ç‰ˆæœ¬æ ¼å¼ï¼ˆå¦‚ï¼š1.0.0ï¼‰`);
            }

            // éªŒè¯ plugins.json ä¸­çš„ ID ä¸å…ƒæ•°æ®ä¸­çš„ name æ˜¯å¦ä¸€è‡´
            if (plugin && plugin.id !== metadata.name) {
              console.warn(`è­¦å‘Šï¼šplugins.json ä¸­çš„æ’ä»¶ ID '${plugin.id}' ä¸ __plugin_meta__ ä¸­çš„åç§° '${metadata.name}' ä¸åŒã€‚å»ºè®®ä¿æŒä¸€è‡´ã€‚`);
            }

            console.log(`æ’ä»¶å…ƒæ•°æ®ç»“æ„æœ‰æ•ˆï¼š${metadata.name} v${metadata.version}`);
          }

          // è¿è¡Œä¸»å‡½æ•°
          main();
          EOL

      # æ­¥éª¤ 7: å…‹éš†æ’ä»¶ä»“åº“å¹¶è¿è¡Œ MPDT æ£€æŸ¥
      - name: Clone plugin repository and run MPDT check
        id: mpdt-check
        if: always()
        run: |
          # è¯»å–éªŒè¯ç»“æœ
          if [ ! -f validation-result.json ]; then
            echo "è·³è¿‡ MPDT æ£€æŸ¥ï¼šæ²¡æœ‰æ‰¾åˆ°éªŒè¯ç»“æœæ–‡ä»¶"
            exit 0
          fi

          # æå–æ’ä»¶ä¿¡æ¯
          NEW_PLUGINS=$(cat validation-result.json | jq -r '.newPlugins[].repositoryUrl // empty')
          MODIFIED_PLUGINS=$(cat validation-result.json | jq -r '.modifiedPlugins[].repositoryUrl // empty')
          
          # åˆå¹¶æ‰€æœ‰éœ€è¦æ£€æŸ¥çš„æ’ä»¶
          ALL_PLUGINS=$(echo -e "$NEW_PLUGINS\n$MODIFIED_PLUGINS" | grep -v '^$' | sort -u)
          
          if [ -z "$ALL_PLUGINS" ]; then
            echo "æ²¡æœ‰éœ€è¦æ£€æŸ¥çš„æ’ä»¶"
            exit 0
          fi

          # åˆå§‹åŒ– JSON æ•°ç»„æ–‡ä»¶
          echo '[]' > mpdt-reports.json

          MPDT_ERRORS=0
          
          # å¯¹æ¯ä¸ªæ’ä»¶è¿›è¡Œæ£€æŸ¥
          while IFS= read -r repo_url; do
            if [ -z "$repo_url" ]; then
              continue
            fi
            
            echo "æ­£åœ¨æ£€æŸ¥æ’ä»¶: $repo_url"
            
            # æå–ä»“åº“åç§°
            REPO_NAME=$(basename "$repo_url" .git)
            PLUGIN_DIR="plugin-check-$REPO_NAME"
            
            # å…‹éš†æ’ä»¶ä»“åº“
            echo "å…‹éš†ä»“åº“åˆ° $PLUGIN_DIR..."
            if ! git clone --depth 1 "$repo_url" "$PLUGIN_DIR" 2>&1 | tee clone-output.txt; then
              echo "## âŒ $REPO_NAME" >> mpdt-report.md
              echo "" >> mpdt-report.md
              echo "**é”™è¯¯**: æ— æ³•å…‹éš†ä»“åº“" >> mpdt-report.md
              echo '```' >> mpdt-report.md
              cat clone-output.txt >> mpdt-report.md
              echo '```' >> mpdt-report.md
              echo "" >> mpdt-report.md
              MPDT_ERRORS=$((MPDT_ERRORS + 1))
              continue
            fi
            
            # æŸ¥æ‰¾æ’ä»¶æ–‡ä»¶æ‰€åœ¨ç›®å½•
            echo "æŸ¥æ‰¾æ’ä»¶æ–‡ä»¶..."
            PLUGIN_PATH="$PLUGIN_DIR"
            
            # æŸ¥æ‰¾ plugin.py æˆ– __init__.py æ–‡ä»¶
            if [ -f "$PLUGIN_DIR/plugin.py" ] ; then
              PLUGIN_PATH="$PLUGIN_DIR"
              echo "âœ“ åœ¨æ ¹ç›®å½•æ‰¾åˆ°æ’ä»¶æ–‡ä»¶"
            else
              # éå†å­ç›®å½•æŸ¥æ‰¾æ’ä»¶æ–‡ä»¶
              for dir in "$PLUGIN_DIR"/*/ ; do
                if [ -d "$dir" ] && ([ -f "${dir}plugin.py" ]); then
                  PLUGIN_PATH="$dir"
                  echo "âœ“ åœ¨ $(basename "$dir") ç›®å½•æ‰¾åˆ°æ’ä»¶æ–‡ä»¶"
                  break
                fi
              done
            fi
            
            # è¿è¡Œ MPDT check
            echo "è¿è¡Œ MPDT æ£€æŸ¥: $PLUGIN_PATH"
            if mpdt check "$PLUGIN_PATH" --report json --output "${PLUGIN_DIR}-report.json" 2>&1 | tee mpdt-output.txt; then
              echo "âœ… MPDT æ£€æŸ¥é€šè¿‡ï¼š$REPO_NAME"
              
              # ä½¿ç”¨ jq å°†æŠ¥å‘Šæ·»åŠ åˆ°æ•°ç»„ä¸­
              if [ -f "${PLUGIN_DIR}-report.json" ]; then
                echo "[DEBUG] æ‰¾åˆ° JSON æŠ¥å‘Šæ–‡ä»¶: ${PLUGIN_DIR}-report.json"
                # å°†æ–°æŠ¥å‘Šæ·»åŠ åˆ°æ•°ç»„ä¸­
                jq -s '.[0] + [.[1]]' mpdt-reports.json "${PLUGIN_DIR}-report.json" > mpdt-reports-tmp.json
                mv mpdt-reports-tmp.json mpdt-reports.json
              fi
            else
              echo "âš ï¸ MPDT æ£€æŸ¥å‘ç°é—®é¢˜ï¼š$REPO_NAME"
              
              # ä½¿ç”¨ jq å°†æŠ¥å‘Šæ·»åŠ åˆ°æ•°ç»„ä¸­
              if [ -f "${PLUGIN_DIR}-report.json" ]; then
                echo "[DEBUG] æ‰¾åˆ° JSON æŠ¥å‘Šæ–‡ä»¶: ${PLUGIN_DIR}-report.json"
                jq -s '.[0] + [.[1]]' mpdt-reports.json "${PLUGIN_DIR}-report.json" > mpdt-reports-tmp.json
                mv mpdt-reports-tmp.json mpdt-reports.json
              else
                echo "[DEBUG] æœªæ‰¾åˆ° JSON æŠ¥å‘Šæ–‡ä»¶"
              fi
              
              MPDT_ERRORS=$((MPDT_ERRORS + 1))
            fi
            
            # æ¸…ç†
            rm -rf "$PLUGIN_DIR"
          done <<< "$ALL_PLUGINS"
          
          # ä¿å­˜é”™è¯¯è®¡æ•°
          echo "MPDT_ERRORS=$MPDT_ERRORS" >> $GITHUB_ENV
          
          # æ˜¾ç¤ºæ”¶é›†çš„æŠ¥å‘Š
          echo "=== MPDT æ£€æŸ¥å®Œæˆ ==="
          if [ $MPDT_ERRORS -gt 0 ]; then
            echo "âš ï¸ MPDT æ£€æŸ¥å‘ç° $MPDT_ERRORS ä¸ªé—®é¢˜"
          else
            echo "âœ… MPDT æ£€æŸ¥å…¨éƒ¨é€šè¿‡"
          fi

      # æ­¥éª¤ 8: å‘å¸ƒæ£€æŸ¥ç»“æœåˆ° PR è¯„è®º
      - name: Post check results to PR
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // æ„å»ºè¯„è®ºå†…å®¹
            let comment = '# ğŸ” æ’ä»¶æäº¤æ£€æŸ¥æŠ¥å‘Š\n\n';
            
            let hasErrors = false;
            let validationResult = null;
            
            // è¯»å–éªŒè¯ç»“æœ
            try {
              validationResult = JSON.parse(fs.readFileSync('validation-result.json', 'utf8'));
            } catch (error) {
              console.log('æ— æ³•è¯»å–éªŒè¯ç»“æœ');
            }
            
            // æ·»åŠ å¿«é€ŸçŠ¶æ€æ¦‚è§ˆ
            const mpdtErrors = process.env.MPDT_ERRORS || '0';
            const hasValidationErrors = validationResult && validationResult.errors.length > 0;
            const hasMpdtErrors = mpdtErrors !== '0';
            hasErrors = hasValidationErrors || hasMpdtErrors;
            
            if (!hasErrors) {
              comment += '## âœ… æ‰€æœ‰æ£€æŸ¥é€šè¿‡\n\n';
              comment += '> ğŸ‰ æ­å–œï¼æ‚¨çš„æ’ä»¶å·²é€šè¿‡æ‰€æœ‰è‡ªåŠ¨åŒ–æ£€æŸ¥ï¼Œå‡†å¤‡è¿›è¡Œäººå·¥å®¡æ ¸ã€‚\n\n';
            } else {
              comment += '## âš ï¸ å‘ç°é—®é¢˜\n\n';
              comment += '> è¯·ä¿®å¤ä»¥ä¸‹é—®é¢˜åé‡æ–°æäº¤ã€‚å¦‚æœ‰ç–‘é—®ï¼Œè¯·æŸ¥çœ‹ [æ’ä»¶å¼€å‘æ–‡æ¡£](https://github.com/MoFox-Studio/MoFox-Plugin-Repo/wiki)ã€‚\n\n';
            }
            
            // å…ƒæ•°æ®éªŒè¯ç»“æœ
            comment += '---\n\n';
            comment += '## ğŸ“‹ å…ƒæ•°æ®éªŒè¯\n\n';
            
            if (validationResult) {
              // æ–°å¢æ’ä»¶
              if (validationResult.newPlugins.length > 0) {
                comment += '### æ–°å¢æ’ä»¶\n\n';
                validationResult.newPlugins.forEach(plugin => {
                  comment += `- âœ… **${plugin.id}**\n`;
                  comment += `  - ä»“åº“: ${plugin.repositoryUrl}\n`;
                });
                comment += '\n';
              }
              
              // ä¿®æ”¹çš„æ’ä»¶
              if (validationResult.modifiedPlugins.length > 0) {
                comment += '### ä¿®æ”¹çš„æ’ä»¶\n\n';
                validationResult.modifiedPlugins.forEach(plugin => {
                  comment += `- ğŸ”„ **${plugin.id}**\n`;
                  comment += `  - ä»“åº“: ${plugin.repositoryUrl}\n`;
                });
                comment += '\n';
              }
              
              // éªŒè¯é”™è¯¯
              if (validationResult.errors.length > 0) {
                comment += '### âŒ éªŒè¯é”™è¯¯\n\n';
                comment += '```\n';
                validationResult.errors.forEach((error, index) => {
                  comment += `${index + 1}. ${error}\n`;
                });
                comment += '```\n\n';
              } else {
                comment += '> âœ… **å…ƒæ•°æ®éªŒè¯é€šè¿‡**\n\n';
              }
            } else {
              comment += '> âš ï¸ æ— æ³•è¯»å–éªŒè¯ç»“æœ\n\n';
            }
            
            // MPDT æ£€æŸ¥ç»“æœ
            comment += '---\n\n';
            comment += '## ğŸ”§ MPDT é™æ€æ£€æŸ¥\n\n';
            
            try {
              const mpdtReportsRaw = fs.readFileSync('mpdt-reports.json', 'utf8');
              const reports = JSON.parse(mpdtReportsRaw);
              
              console.log('[DEBUG] MPDT æŠ¥å‘Šæ•°é‡:', reports.length);
              
              if (!Array.isArray(reports) || reports.length === 0) {
                comment += '> âš ï¸ MPDT æ£€æŸ¥æœªè¿è¡Œæˆ–æœªç”ŸæˆæŠ¥å‘Š\n\n';
              } else {
                let totalErrors = 0;
                let totalWarnings = 0;
                let totalInfo = 0;
                let allIssues = [];
                
                // è§£ææ¯ä¸ª JSON æŠ¥å‘Š
                reports.forEach((report, index) => {
                  console.log(`[DEBUG] è§£ææŠ¥å‘Š ${index + 1}:`, JSON.stringify(report.summary));
                  
                  totalErrors += report.summary.total_errors || 0;
                  totalWarnings += report.summary.total_warnings || 0;
                  totalInfo += report.summary.total_info || 0;
                  
                  // æ”¶é›†é—®é¢˜
                  if (report.issues && Array.isArray(report.issues)) {
                    allIssues.push(...report.issues);
                  }
                });
                
                console.log('[DEBUG] æ±‡æ€» - é”™è¯¯:', totalErrors, 'è­¦å‘Š:', totalWarnings, 'ä¿¡æ¯:', totalInfo);
                console.log('[DEBUG] æ€»é—®é¢˜æ•°:', allIssues.length);
                
                if (totalErrors === 0 && totalWarnings === 0) {
                  comment += '> âœ… **MPDT æ£€æŸ¥é€šè¿‡**\n\n';
                } else {
                  comment += `**æ£€æŸ¥æ‘˜è¦**: ${totalErrors} ä¸ªé”™è¯¯, ${totalWarnings} ä¸ªè­¦å‘Š\n\n`;
                  
                  // æ˜¾ç¤ºé”™è¯¯
                  const errors = allIssues.filter(issue => issue.level === 'error');
                  if (errors.length > 0) {
                    comment += '### âŒ é”™è¯¯\n\n';
                    errors.forEach((issue, index) => {
                      comment += `${index + 1}. **[${issue.validator}]** ${issue.message}\n`;
                      if (issue.file_path) {
                        comment += `   ğŸ“ \`${issue.file_path}\``;
                        if (issue.line_number) {
                          comment += `:${issue.line_number}`;
                        }
                        comment += '\n';
                      }
                      if (issue.suggestion) {
                        comment += `   ğŸ’¡ *${issue.suggestion}*\n`;
                      }
                      comment += '\n';
                    });
                  }
                  
                  // æ˜¾ç¤ºè­¦å‘Šï¼ˆé™åˆ¶æ•°é‡ï¼‰
                  const warnings = allIssues.filter(issue => issue.level === 'warning');
                  if (warnings.length > 0) {
                    comment += '### âš ï¸ è­¦å‘Š\n\n';
                    const displayWarnings = warnings.slice(0, 15); // åªæ˜¾ç¤ºå‰10ä¸ª
                    displayWarnings.forEach((issue, index) => {
                      comment += `${index + 1}. **[${issue.validator}]** ${issue.message}\n`;
                      if (issue.file_path) {
                        comment += `   ğŸ“æ–‡ä»¶è·¯å¾„ï¼š \`${issue.file_path}\``;
                        if (issue.line_number) {
                          comment += `:${issue.line_number}`;
                        }
                        comment += '\n';
                      }
                      if (issue.suggestion) {
                        comment += `   ğŸ’¡ *${issue.suggestion}*\n`;
                      }
                      comment += '\n';
                    });
                    if (warnings.length > 10) {
                      comment += `\n*...è¿˜æœ‰ ${warnings.length - 10} ä¸ªè­¦å‘Šæœªæ˜¾ç¤º*\n`;
                    }
                    comment += '\n> ğŸ’¡ è™½ç„¶è­¦å‘Šä¸ä¼šé˜»æ­¢æäº¤ï¼Œä½†å»ºè®®å¼€å‘è€…ä¿®å¤è¿™äº›é—®é¢˜ä»¥æé«˜æ’ä»¶è´¨é‡ã€‚\n\n';
                  }
                }
              }
            } catch (error) {
              console.error('[DEBUG] è¯»å–æˆ–è§£æ MPDT æŠ¥å‘Šå¤±è´¥:', error.message);
              comment += '> âš ï¸ MPDT æ£€æŸ¥æœªè¿è¡Œæˆ–æœªç”ŸæˆæŠ¥å‘Š\n\n';
            }
            
            // æ·»åŠ åº•éƒ¨è¯´æ˜
            comment += '---\n\n';
            if (!hasErrors) {
              comment += '### ğŸ“ ä¸‹ä¸€æ­¥\n\n';
              comment += '- ç»´æŠ¤è€…å°†å°½å¿«å®¡æ ¸æ‚¨çš„æäº¤\n';
              comment += '- æ‚¨å¯èƒ½ä¼šæ”¶åˆ°è¿›ä¸€æ­¥çš„åé¦ˆæˆ–ä¿®æ”¹å»ºè®®\n';
              comment += '- æ„Ÿè°¢æ‚¨ä¸º MoFox æ’ä»¶ç”Ÿæ€åšå‡ºè´¡çŒ®ï¼ ğŸ™\n\n';
            } else {
              comment += '### ğŸ’¡ éœ€è¦å¸®åŠ©ï¼Ÿ\n\n';
              comment += '- ğŸ“– æŸ¥çœ‹ [æ’ä»¶å¼€å‘æ–‡æ¡£](https://github.com/MoFox-Studio/MoFox-Plugin-Repo/wiki)\n';
              comment += '- ğŸ’¬ åœ¨ Issue ä¸­ç•™è¨€è¯¢é—®\n';
              comment += '- ğŸ”§ ä½¿ç”¨ `mpdt check` å‘½ä»¤åœ¨æœ¬åœ°æµ‹è¯•\n\n';
            }
            
            comment += '<sub>ğŸ¤– æ­¤æŠ¥å‘Šç”±è‡ªåŠ¨åŒ–å·¥ä½œæµç”Ÿæˆ</sub>';
            
            // å‘å¸ƒè¯„è®º
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            // æŸ¥æ‰¾ä¹‹å‰çš„è‡ªåŠ¨è¯„è®º
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              (comment.body.includes('ğŸ” æ’ä»¶æäº¤æ£€æŸ¥ç»“æœ') || comment.body.includes('ğŸ” æ’ä»¶æäº¤æ£€æŸ¥æŠ¥å‘Š'))
            );
            
            if (botComment) {
              // æ›´æ–°ç°æœ‰è¯„è®º
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              // åˆ›å»ºæ–°è¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
